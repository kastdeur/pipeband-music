#!/usr/bin/python3.4

# To be Run: python3.4 makebook -v -o ./tex/main_pipes.tex pipes
# Uses a copy of the filestructure of pipeband-drumming to generate the body of a tex file

import os
from argparse import ArgumentParser

class MakeBook:
	OUT = './tex/main.tex'
	MASTER_DIR = os.path.dirname(os.path.abspath(__file__))
	RUN_DIR = os.path.abspath(os.curdir)
	SCORES_DIR = './scores/'
	LY_DIR = '../'
	ORDER_FILE = 'order.txt'
	INSTRUMENTS = ['full','drums', 'pipes', 'bass', 'tenor', 'side','snare']
	def __init__(self):

		usage = __file__
		parser = ArgumentParser(usage)
		parser.add_argument('-v','--verbose',default=False,action='store_true',dest='verbose', help='verbose')
		parser.add_argument('instrument',default=False,nargs='*',help='Instruments to be included in the book')
		parser.add_argument('-o','--output',default=self.OUT,help='Output file')

		self.args = parser.parse_args()

		if self.args.verbose:
			self.vprint('Verbose output')
		standards = ['standards']
		marches = ['2-4_marches', '3-4_marches', '4-4_marches', '5-4_marches', '6-8_marches']
		watch_folders = [ 'hornpipes', 'jigs', 'strathspeys', 'reels','other']
		watch_folders = marches + watch_folders

		# Run Path_walker over dirs
		tune_dirs = []
		for d in watch_folders:
			if d in marches:
				continue
			tune_dirs.append(d)

		# Ready f.out
		try:
			self.fout = open(self.args.output,'w+')

			self.fwrite(u'\\addcontentsline{toc}{section}{Standards}')
			for d in standards:
				self.vprint()
				self.vprint(os.path.join(self.SCORES_DIR,d))
				self.path_walker(os.path.join(self.SCORES_DIR,d), level=1, content_line_level=1)
			self.fwrite(u'\\addcontentsline{toc}{section}{Marches}')
			for d in marches:
				self.vprint()
				self.vprint(os.path.join(self.SCORES_DIR,d))
				self.path_walker(os.path.join(self.SCORES_DIR,d), level=1, content_line_level=2)

			for d in tune_dirs:
				self.vprint()
				self.vprint(os.path.join(self.SCORES_DIR,d))
				self.path_walker(os.path.join(self.SCORES_DIR,d))
		except IOError:
			print('Cannot open {}'.format(self.OUT))
		except:
			self.fout.close()
			raise

	def vprint(self,line = None):
		if self.args.verbose:
			if line is None:
				line = ''
			print(line)

	def fwrite(self,line):
		self.fout.write(line+'\n')

	def include_pdf (self,file, level):
		title = False
		self.vprint(file)
		lilydir = file[:file.rfind('/')].replace(self.SCORES_DIR,self.LY_DIR)
		if os.path.isdir(lilydir):
			path = file[:file.rfind('/')]
			#Try to load title from config file
			if os.path.isfile(os.path.join(lilydir,'config.ily')):
				self.vprint('Loading config file')
				with open(os.path.join(lilydir,'config.ily'),'r') as f:
					for line in iter(f):
						if line.startswith('title'):
							title = line[line.find('=')+1:]#Strip 'title='
							title = title[1:-1] #Strip Quotes
							continue

			lilyfile = os.path.join(lilydir, file[file.rfind('-')+1:].replace('.pdf','.ly'))
			if not title and os.path.isfile(lilyfile):
				self.vprint('Look through lilyfile')
				with open(lilyfile, 'r') as f:
					for line in iter(f):
						if line.strip().startswith('title'):
							title = line[line.find('=')+1:]#Strip 'title='
							title = title[1:-1] #Strip Quotes
							continue
			if title:
				ref = title
				forbid = ' /!@#$%^&*()<>?\|;:\'"'
				for s in forbid:
					ref = ref.replace(s,'_')
		if not title:
			self.vprint('No title yet Found!')
			last_slash = file.rfind('/')
			last_dot = file.rfind('.')

			if file[file.rfind('.',0,last_dot)+1:file.rfind('.')] in self.INSTRUMENTS:
				ref = file[file.rfind('/')+1:file.rfind('.')]
			else :
				ref = file[file.rfind('/',0,last_slash-1)+1:file.rfind('.')].replace('/','-')
			# Make title from filename
			title = ref
			#Remove references to Instruments
			for inst in self.INSTRUMENTS:
				title = title.replace('-'+inst, '')
				title = title.replace('.'+inst, '')
			#Remove chars
			title = title.replace('-','').replace('_',' ').title()

		title = title[1:-1].replace('\\n',' ')

		if not self.args.instrument:
				for inst in self.INSTRUMENTS:
					if inst in file:
						title = title + ' ('+inst+')'
		self.vprint('= '+title)
		ref = 'p'+ref.strip('_').lower()
		#string = u'\\includepdf[pages=-, addtotoc={1,'+('sub'*level)+'section,'+str(level+1)+','+title+','+ref+'}, pagecommand={}]{'+file+'}'
		string = u'\\includepdf[pages=-, addtotoc={1,'+('sub'*level)+'section,'+str(level+1)+',{'+title+'},'+ref+'}, pagecommand={}]{'+file+'}'

		self.fwrite(string)
		return string

	def path_walker(self, a, level=None, content_line_level=None):
		if not a:
			return
		if level is None:
			level = 0
		if content_line_level is None:
			content_line_level = 1
		# Do stuff
		if level < content_line_level:
			self.fwrite(u'\\mysection{'+('sub'*level)+'section}{'+a[a.rfind('/')+1:].replace('_',' ').replace('-','/').title()+'}')
		newline = False

		if os.path.isfile(os.path.join(a, 'order.txt')):
			self.vprint('Found order')
			with open(os.path.join(a, self.ORDER_FILE)) as f:
				line = f.readline().rstrip('\n')
				while line:
					self.path_walker(os.path.join(a,line), level+1)
					line = f.readline().rstrip('\n')
		else:
			for root, dirs, files in os.walk(a,False):
				for f in files:
					if not f.endswith('.pdf'):
						self.vprint('F! '+f)
						continue
					if self.args.instrument:
						instr_in_file = False
						for instr in self.args.instrument:
							if instr in f:
								self.vprint(instr)
								instr_in_file = True
								break
						if not instr_in_file:
							self.vprint('F! '+f)
							continue
					# Include file
					self.vprint('F '+f)
					if newline:
						self.fwrite(u'\\newpage')

					newline = True
					self.include_pdf(os.path.join(root,f), level+1)
# Run above
MakeBook();
